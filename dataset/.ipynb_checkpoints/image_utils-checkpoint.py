from imgaug import augmenters as iaa
import imgaug as ia 
import numpy as np
from torchvision import transforms 
import torch
import random
import pickle 
"""
Classes for basic image operations:
    Standardizer 
    Augmenters
        Crop
        Rotate
        Flip 

"""



class ImageStandardizer(object):
    """
    Channel-wise standardization for batch of images to mean 0 and variance 1. 
    The mean and standard deviation parameters are computed in `fit(X)` and
    applied using `transform(X)`.
    
    X has shape (N, image_height, image_width, color_channel)
    """
    def __init__(self, image_mean = None, image_std = None):
        super().__init__()
        self.image_mean = image_mean
        self.image_std = image_std
    
    def _get_weights(self,image):
        return image[0].shape[0] * image[0].shape[1]
    
    def _get_mean(self, image):
        return np.mean(image[0])
    def _get_std_mean(self, image):
        return np.mean(image[0] - self.image_mean) ** 2
    
    def fit(self, X):
        weights = list(map(self._get_weights,X))
        means = list(map(self._get_mean,X))
        self.image_mean = np.average(means, weights = weights)
        means_std  = list(map(self._get_std_mean, X))
        variance = np.average(means_std, weights=weights)

        self.image_std = np.sqrt(variance) 
        
    def _transform_image(self, image):
         return (image - self.image_mean) / self.image_std
    
    def transform(self, X):
        # TODO: Complete this function
        return list(map(self._transform_image, X))

    

""" 

Image Transform classes for data augmentation 

"""

class RandomCrop():
    """Crop randomly the image in a sample.

    Args:
        output_size (tuple or int): Desired output size. If int, square crop
            is made.
        psition (string): "uniform" for training/validation. 
                           "center" for testing. 
    """
    
    def __init__(self, seed, output_size, position):
        
        ia.seed(seed)
        torch.manual_seed(seed)
        np.random.seed(seed)
        random.seed(seed)
        torch.backends.cudnn.deterministic = True
        torch.backends.cudnn.benchmark = False
        torch.cuda.manual_seed(seed)
        torch.cuda.manual_seed_all(seed)

        assert isinstance(output_size, (int, tuple))
        if isinstance(output_size, int):
            self.output_size = (output_size, output_size)
        else:
            assert len(output_size) == 2
            self.output_size = output_size
        
        assert isinstance(position, (str))
        self.position = position
        
        if (self.position == "center"):
            self.crop = iaa.CropToFixedSize(width = self.output_size[0], height = self.output_size[1], position = "center") 
        else:
            self.crop = iaa.CropToFixedSize(width = self.output_size[0], height = self.output_size[1], position = "uniform") 
            
    def __call__(self, image):
        img = self.crop.augment_image(image)
        return img
    
class RandomFlip():
    """Flip randomly the image in a sample.

    Args:
        probability: likelihood that an image will get flipped 
    """
    
    def __init__(self, seed, probability):
        
        ia.seed(seed)
        torch.manual_seed(seed)
        np.random.seed(seed)
        random.seed(seed)
        torch.backends.cudnn.deterministic = True
        torch.backends.cudnn.benchmark = False
        torch.cuda.manual_seed(seed)
        torch.cuda.manual_seed_all(seed)
        
        self.probability = probability
        self.flip = iaa.Fliplr(self.probability) # horizontally flip images with some probability
            
    def __call__(self, image):
        
        return self.flip.augment_image(image)

    
class RandomRotate():
    """Rotates randomly the image in a sample.

    Args:
        degrees (int or tuple): range of degrees that an image can be rotates
    """
    
    def __init__(self,seed,  degrees):
        
        ia.seed(seed)
        torch.manual_seed(seed)
        np.random.seed(seed)
        random.seed(seed)
        torch.backends.cudnn.deterministic = True
        torch.backends.cudnn.benchmark = False
        torch.cuda.manual_seed(seed)
        torch.cuda.manual_seed_all(seed)
        assert isinstance(degrees, (int, tuple))
        if isinstance(degrees, int):
            self.degrees = (-degrees, degrees)
        else:
            assert len(degrees) == 2
            self.degrees = degrees
        self.rotate = iaa.Affine(rotate = self.degrees) # rotate the image between -15 and 15 degrees 
            
    def __call__(self, image):
        return self.rotate.augment_image(image)
    
    

