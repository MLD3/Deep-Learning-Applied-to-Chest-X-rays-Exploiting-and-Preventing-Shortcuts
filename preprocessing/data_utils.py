import numpy as np 
from scipy.stats import spearmanr
from itertools import combinations

def split_meta(meta, splits_orig, split_labels):
    try:
        assert(sum(splits_orig) == 1)
    except:
        print("Sum of split division % does not equal 1")
    splits = splits_orig.copy()
    splits.insert(0,0)
    splits = np.cumsum(splits)

    patients = meta.pt_id.unique()
    total = len(patients)
    pts_in_split = []
    for i in range(len(splits) - 1):
        pts_in_split.append(patients[int(splits[i] * total): int(splits[i+1] * total)])

    meta.split = ""
    for idx, label in enumerate(split_labels):
        meta.split[meta.pt_id.isin(pts_in_split[idx])] = label
        assert(np.abs(len(meta[meta.split == label].drop_duplicates("pt_id")) - int(splits_orig[idx] * len(meta.drop_duplicates("pt_id")))) <= 1)
    return meta


def threshold(meta, threshold, less_value):
    ones = meta < threshold
    zeros = meta > threshold
    meta[ones]= less_value
    meta[zeros] = 1 - less_value
    return meta

def check_pt_overlap(meta, splits):
    pts_all =[]
    for split in splits:
        pts = meta.pt_id[meta.split == split].unique()
        pts_all.append(pts)
    for x, y in combinations(pts_all, 2):
        try:
            assert(not np.intersect1d(x,y))
        except:
            return 0 
    return 1 


def get_correls(df, diagnosis, bias, splits):
    return [spearmanr(df[df.split == split][diagnosis], df[df.split == split][bias])[0] for split in splits]
